import enum
import time

from typing import List, Optional, Tuple, Dict, Union, Iterable

from .policy import PolicyFactory
from .wrappers import Request, RequestStatus, SchedulerOutput
from sduss.config import SchedulerConfig
from sduss.logger import init_logger
from sduss.utils import Counter

logger = init_logger(__name__)

class PreemptionMode(enum.Enum):
    """Preemption Modes

    Attributes:
        SWAP: Swap out the blocks of the preempted sequences to CPU memory
            and swap the back in when the sequences are resumed.
        RECOMPUTE: Discard the blocks of the preempted sequences and recompute
            them when the sequences are resumed, treating the sequences as
            new prompts.
    """
    SWAP = enum.auto()
    RECOMPUTE  = enum.auto()


StateQueue = Tuple[List[Request], int, RequestStatus]
        
class Scheduler:
    """Main scheduler which arranges tasks.
    
    Attributes:
        prompt_limit: Length limit of the prompt derived from configuration.
    """
    
    def __init__(
        self,
        scheduler_config: SchedulerConfig,
    ) -> None:
        self.scheduler_config = scheduler_config

        # Unpack scheduler config's argumnents
        self.max_batchsize = scheduler_config.max_batchsize
        
        # Scheduler policy
        self.policy = PolicyFactory.get_policy(policy_name="fcfs")

        # name -> (list, priority, RequestStatus)
        # Priority here only reflects the order of process stage
        self.state_queue: Dict[str, StateQueue]= {}
        
        # Requests in the SWAPPED state.
        self.swapped: List[Request] = []
        self._register_state_queue("swapped", 0, RequestStatus.SWAPPED)
        # Requests in the WAITING state. Haven't started to run.
        self.waiting: List[Request] = []
        self._register_state_queue("waiting", 10, RequestStatus.WAITING)
        # Requests in the RUNNING state.
        self.prepare: List[Request] = []
        self._register_state_queue("prepare", 20, RequestStatus.PREPARE)
        self.denoising: List[Request] = []
        self._register_state_queue("denoising", 30, RequestStatus.DENOISING)
        self.postprocess: List[Request] = []
        self._register_state_queue("postprocessing", 40, RequestStatus.POSTPROCESSING)

        
    def add_request(self, req: Request) -> None:
        """Add a new request to waiting queue."""
        self.waiting.append(req)

        
    def abort_request(self, request_ids: Union[int, Iterable[int]]) -> None:
        """Abort a handful of requests.

        Args:
            request_ids (Union[str, Iterable[str]]): Requests to be aborted.
        """        
        if isinstance(request_ids, int):
            request_ids = (request_ids, )  # transform into an iterable
        request_ids = set(request_ids)
        
        for state_queue in self.state_queue.values():
            # To perform removal correctly, we have to iterate reversely.
            for req in reversed(state_queue[0]):
                if req.request_id in request_ids:
                    state_queue.remove(req)  # Untrack
                    req.status = RequestStatus.FINISHED_ABORTED
                    request_ids.remove(req.request_id)
                    if not request_ids:  # early exit
                        return

        
    def free_finished_requests(self) -> None:
        """Untrack all finished requests."""
        self.running = [
            req for req in self.running
            if not req.is_finished()
        ]

    
    def has_unfinished_requests(self) -> bool:
        return self.waiting or self.running or self.swapped


    def get_num_unfinished_requests(self) -> int:
        return len(self.waiting) + len(self.running) + len(self.swapped)

    
    def _decide_stage(self) -> RequestStatus:
        target_queue = self.policy.decide_stage(self.state_queue)
        if target_queue is None:
            raise RuntimeError("No queue in scheduler has remaining requsts to process.")
        return target_queue

    
    def _get_next_stage(self, target: List[Request]) -> Optional[List[Request]]:
        # TODO(MX): Swapped stage may not be properly handled
        if target is self.waiting:
            return self.prepare
        elif target is self.swapped or target is self.prepare:
            return self.denoising
        elif target is self.denoising:
            return self.postprocess
        elif target is self.postprocess:
            return None
        
    
    def _schedule(self) -> SchedulerOutput:
        """Schedules running and swapping operations.

        Returns:
            SchedulerOutputs: All information generated by scheduling.
        """        

        # Fix the current time
        now = time.monotonic()
        
        # Decide which stage for this iteration
        target_status = self._decide_stage()
        target_queue = self._get_queue_from_status(target_status)
        
        cur_batchsize = 0
        collected_reqs = []
        sorted_queue = self.policy.sort_by_priority(now, target_queue)
        for req in sorted_queue:
            # TODO(MX): Currently we cannot handle any single request
            # that contains num_imgs > self.max_batchsize.
            req_size = req.sampling_params.num_imgs
            if req_size + cur_batchsize > self.max_batchsize:
                break
            
            collected_reqs.append(req)
            cur_batchsize += req_size


        scheduler_outputs = SchedulerOutput(
            scheduled_requests=collected_reqs,
            prompt_run=True if target_status == RequestStatus.WAITING else False,
        )
        return scheduler_outputs
                
            
    def schedule(self) -> SchedulerOutput:
        """Schedule requests for next iteration."""
        scheduler_outputs = self._schedule()

        # More wrappers will be added here.
        
        return scheduler_outputs
    
    
    def update_reqs_status(self):
        """Update requests after one iteration."""
        # Move this req to next queue
        # Update its status
        pass
        
        
    def _register_state_queue(self, name: str, priority: int) -> None:
        queue = getattr(self, name, None)
        if queue is None:
            raise ValueError(f"Non-existent queue {name} cannot be registered.")
        self.state_queue[name] = (queue, priority)

    
    def _get_queue_from_name(self, name: str) -> List[Request]:
        if name not in self.state_queue.keys():
            raise RuntimeError("Invalid queue name was requested.")
        return self.state_queue[name][0]

    
    def _get_queue_from_status(self, status: RequestStatus) -> List[Request]:
        if status == RequestStatus.WAITING:
            return self.waiting
        elif status == RequestStatus.PREPARE:
            return self.prepare
        elif status == RequestStatus.DENOISING:
            return self.state_queue
        elif status == RequestStatus.POSTPROCESSING:
            return self.postprocess
        elif status == RequestStatus.SWAPPED:
            return self.swapped
        

 